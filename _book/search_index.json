[["network.html", "Chapter 4 Network Analysis 4.1 Community detection", " Chapter 4 Network Analysis One way of conceptualizing meaningful cultural groupings could involve using the idea of networks consisting of nodes and edges. A common way of representing graphs in social network analysis involves representing nodes as people where th edges indicate some mathematical relation between the nodes. As a thought experiment one could think of these edges as psychological distances between people. The valence (positive or negative) of these edges could indicate similarity (or dissimilarity) in the thought processes of people. The weights of these edges (indicated by the thickness of the edges in the graph) could indicate the magnitude or strength of the similarity (or dissimilarity) in the thought processes of people. Once we are able to conceptualize the edges as thinking patterns, we need a way to find meaningful clusters or communities in the graph that will indicate groups that are similar to each other in their ways of thinking. Identification of such groups will involve algorithms that seek to find commonalities in the nodes and group them according to other similar nodes. This process in network analysis can be defined as community detection. 4.1 Community detection The conceptual understanding of communities in the real world involves a level of consensus or agreement between members of the same community. For the purpose of demonstration we will be modeling psychological distances as personality variables and as Emancipative values. The community detection algorithms allow for mathematically modeling this idea of identifying clusters or communities in a network of participants which could be potential proxies of culture relevant groups in the data. #Libraries library(igraph) library(psych) 4.1.1 Personality data set.seed(229) #222 gave a sd = 0 #Raw data data_bfi &lt;- bfi %&gt;% select(-gender, -education, -age) %&gt;% drop_na() %&gt;% sample_n(200) %&gt;% # rowwise() %&gt;% # mutate(A = sum(c(A1, A2, A3, A4,A5)), # C = sum(c(C1, C2, C3, C4,C5)), # N = sum(c(N1, N2, N3, N4, N5)), # O = sum(c(O1, O2, O3, O4, O5)), # E = sum(c(E1, E2, E3, E4, E5))) %&gt;% # dplyr::select(A, C, N, O, E) %&gt;% t %&gt;% as.data.frame() %&gt;% janitor::clean_names() %&gt;% rename_all(funs(stringr::str_replace_all(., &#39;v&#39;, &#39;p&#39;))) %&gt;% cor #Ipsatized data data_bfi_ip &lt;- bfi %&gt;% select(-gender, -education, -age) %&gt;% drop_na() %&gt;% multicon::ipsatize() %&gt;% sample_n(200) %&gt;% t %&gt;% as.data.frame() %&gt;% janitor::clean_names() %&gt;% rename_all(funs(stringr::str_replace_all(., &#39;v&#39;, &#39;p&#39;))) %&gt;% cor #Plot the correlations - raw reshape2::melt(data_bfi) %&gt;% ggplot(aes(x=value)) + geom_density(fill=&quot;#69b3a2&quot;, color=&quot;#e9ecef&quot;, alpha=0.8)+ labs(title = &quot;Distribution of correlations - Raw data&quot;, x = &quot;Range of correlation values&quot;)+ theme_ipsum() + theme(plot.title = element_text(size=9)) #Plot the correlations - ipsatized reshape2::melt(data_bfi_ip) %&gt;% ggplot(aes(x=value)) + geom_density(fill=&quot;#69b3a2&quot;, color=&quot;#e9ecef&quot;, alpha=0.8)+ labs(title = &quot;Distribution of correlations - Ipsatized data&quot;, x = &quot;Range of correlation values&quot;)+ theme_ipsum() + theme(plot.title = element_text(size=9)) "],["what-is-community-detection.html", "Chapter 5 What is Community detection? 5.1 Values data", " Chapter 5 What is Community detection? Community detection is the process of identifying similar nodes in a network. In order to find these similar nodes or communities we will be employing different algorithms based on Exploratory Graph analysis (EGA). EGA is a network psychometrics framework that intends to find clusters or communities within network models. The first step is to apply the graphical least absolute shrinkage and selector operator (GLASSO) to an inverse covariance matrix. This results in a Gaussian graphical model (or a network) wherein the edges are partial correlations and the nodes are targets. These targets are variables/features when applied to latent variable modeling. These targets would be, in our case, people. The networks would thus involve understanding the communities of participants in the data holding all the other connections constant (since we use partial correlation graphs). After estimating this graph we can further apply community detection algorithms to find the right connections between participants. The underlying framework for every community detection (CD) algorithm is slightly different from each other. We will be exploring the CD algorithms in the igraph package in R. Before we move on the algorithms it is important to understand one concept that will potentially affect the generation of these communities. The concept of modularity(Newman, 2006) is crucial to understanding any CD algorthim. Modularity in effect is the degree to which communities in a network have larger number of connections within the community in contrast to lesser connections outside the community. \\[ Q = 1/2w \\Sigma_{ij}(w_{ij}- \\frac{w_iw_j}{2w}) \\delta(c_i,c_j) \\] \\[w_{ij}\\] = edge strength (e.g., correlation) between nodes \\[i\\] and \\[j\\] \\[w_i\\] and \\[w_j\\] = node strength (e.g., correlation) for nodes \\[i\\] and \\[j\\] \\[w\\] = summation of all edge weights in the network \\[c_i\\], \\[c_j\\] = community that node \\[i\\] and node \\[j\\] belong to \\[\\delta\\] takes values 1 (when nodes \\[i\\] and \\[j\\] belong to the same community) and 0 (when nodes \\[i\\] and \\[j\\] belong to different communities) is 1 if the nodes belong to the same community (i.e., \\[c_i = c_j\\] ) and 0 if otherwise. Edge Betweenness This algorithm is based on the measure of betweenness cetrality in network graphs. The edge betweenness scores are computed based on how many shortest paths pass through a given edge in the network. The edge betweenness CD algorithm relies on the fact that edges with high betweenness are likely to connect multiple groups as these will the only ways for different groups/communities in the network to stay connected. The edge with the highest betweenness value is removed, followed by recomputing of betweenness for the remaining edges. The new highest betweenness value is identified and removed followed by another round of recomputation. An optimal threshold is established using modularity. # edge betweenness set.seed(98) data_bfi_eb &lt;- bfi %&gt;% select(-gender, -education, -age) %&gt;% drop_na() %&gt;% sample_n(70) %&gt;% t %&gt;% as.data.frame() %&gt;% janitor::clean_names() %&gt;% rename_all(funs(stringr::str_replace_all(., &#39;v&#39;, &#39;p&#39;))) %&gt;% cor g &lt;- graph.adjacency(data_bfi_eb , mode=&quot;upper&quot;, weighted=TRUE, diag=FALSE) e &lt;- get.edgelist(g) df &lt;- as.data.frame(cbind(e,E(g)$weight)) df &lt;- graph_from_data_frame(df, directed = F) eb &lt;- edge.betweenness.community(df) plot(eb, df) Fast and Greedy This algorithm begins with considering every node as one community and uses heirarchical clustering to build communities. Each node is placed in a community in a way that maximizes modularity. The communities are collapsed into different groups once the modularity threshold has been reached (i.e. no significant improvement in modularity is observed). Due to the high speed of this algorithm it is often a preferred approach for quick approximations of communities in the data. g &lt;- graph.adjacency(data_bfi, mode=&quot;upper&quot;, weighted=TRUE, diag=FALSE) e &lt;- get.edgelist(g) df &lt;- as.data.frame(cbind(e,E(g)$weight)) df &lt;- graph_from_data_frame(df, directed = F) #Fast and greedy algorithm fg &lt;- fastgreedy.community(df); fg ## IGRAPH clustering fast greedy, groups: 2, mod: 5.8e-17 ## + groups: ## $`1` ## [1] &quot;p1&quot; &quot;p2&quot; &quot;p3&quot; &quot;p4&quot; &quot;p5&quot; &quot;p6&quot; &quot;p7&quot; &quot;p8&quot; &quot;p9&quot; &quot;p10&quot; ## [11] &quot;p11&quot; &quot;p12&quot; &quot;p13&quot; &quot;p14&quot; &quot;p15&quot; &quot;p16&quot; &quot;p17&quot; &quot;p18&quot; &quot;p19&quot; &quot;p20&quot; ## [21] &quot;p21&quot; &quot;p22&quot; &quot;p23&quot; &quot;p24&quot; &quot;p25&quot; &quot;p26&quot; &quot;p27&quot; &quot;p28&quot; &quot;p29&quot; &quot;p30&quot; ## [31] &quot;p31&quot; &quot;p32&quot; &quot;p33&quot; &quot;p34&quot; &quot;p35&quot; &quot;p36&quot; &quot;p37&quot; &quot;p38&quot; &quot;p39&quot; &quot;p40&quot; ## [41] &quot;p41&quot; &quot;p42&quot; &quot;p43&quot; &quot;p44&quot; &quot;p45&quot; &quot;p46&quot; &quot;p47&quot; &quot;p48&quot; &quot;p49&quot; &quot;p50&quot; ## [51] &quot;p51&quot; &quot;p52&quot; &quot;p53&quot; &quot;p54&quot; &quot;p55&quot; &quot;p56&quot; &quot;p57&quot; &quot;p58&quot; &quot;p59&quot; &quot;p60&quot; ## [61] &quot;p61&quot; &quot;p62&quot; &quot;p63&quot; &quot;p64&quot; &quot;p65&quot; &quot;p66&quot; &quot;p67&quot; &quot;p68&quot; &quot;p69&quot; &quot;p70&quot; ## [71] &quot;p71&quot; &quot;p72&quot; &quot;p73&quot; &quot;p74&quot; &quot;p75&quot; &quot;p76&quot; &quot;p77&quot; &quot;p78&quot; &quot;p79&quot; &quot;p80&quot; ## [81] &quot;p81&quot; &quot;p82&quot; &quot;p83&quot; &quot;p84&quot; &quot;p85&quot; &quot;p86&quot; &quot;p87&quot; &quot;p88&quot; &quot;p89&quot; &quot;p90&quot; ## + ... omitted several groups/vertices # membership(fg) # communities(fg) Louvian This is similar to the greedy algorithm described above. This algorithm also uses heirarchical clustering. It intends to identify heirarchical structures wherein it swaps nodes between communities to assess improvement in modularity. Once the modularity reaches a point where no improvement is observes, the communities are modeled as latent nodes and edge weights with other nodes within and outside the community are computed. This provides a heirarchical or a multi-level structure to the communities identified. The results of Lovian and Fast Greedy algorithms are therefore, likely to be similar. # Louvain lc &lt;- cluster_louvain(df);lc ## IGRAPH clustering multi level, groups: 1, mod: 0 ## + groups: ## $`1` ## [1] &quot;p1&quot; &quot;p2&quot; &quot;p3&quot; &quot;p4&quot; &quot;p5&quot; &quot;p6&quot; &quot;p7&quot; &quot;p8&quot; &quot;p9&quot; &quot;p10&quot; ## [11] &quot;p11&quot; &quot;p12&quot; &quot;p13&quot; &quot;p14&quot; &quot;p15&quot; &quot;p16&quot; &quot;p17&quot; &quot;p18&quot; &quot;p19&quot; &quot;p20&quot; ## [21] &quot;p21&quot; &quot;p22&quot; &quot;p23&quot; &quot;p24&quot; &quot;p25&quot; &quot;p26&quot; &quot;p27&quot; &quot;p28&quot; &quot;p29&quot; &quot;p30&quot; ## [31] &quot;p31&quot; &quot;p32&quot; &quot;p33&quot; &quot;p34&quot; &quot;p35&quot; &quot;p36&quot; &quot;p37&quot; &quot;p38&quot; &quot;p39&quot; &quot;p40&quot; ## [41] &quot;p41&quot; &quot;p42&quot; &quot;p43&quot; &quot;p44&quot; &quot;p45&quot; &quot;p46&quot; &quot;p47&quot; &quot;p48&quot; &quot;p49&quot; &quot;p50&quot; ## [51] &quot;p51&quot; &quot;p52&quot; &quot;p53&quot; &quot;p54&quot; &quot;p55&quot; &quot;p56&quot; &quot;p57&quot; &quot;p58&quot; &quot;p59&quot; &quot;p60&quot; ## [61] &quot;p61&quot; &quot;p62&quot; &quot;p63&quot; &quot;p64&quot; &quot;p65&quot; &quot;p66&quot; &quot;p67&quot; &quot;p68&quot; &quot;p69&quot; &quot;p70&quot; ## [71] &quot;p71&quot; &quot;p72&quot; &quot;p73&quot; &quot;p74&quot; &quot;p75&quot; &quot;p76&quot; &quot;p77&quot; &quot;p78&quot; &quot;p79&quot; &quot;p80&quot; ## [81] &quot;p81&quot; &quot;p82&quot; &quot;p83&quot; &quot;p84&quot; &quot;p85&quot; &quot;p86&quot; &quot;p87&quot; &quot;p88&quot; &quot;p89&quot; &quot;p90&quot; ## + ... omitted several groups/vertices # membership(lc) # communities(lc) # plot(lc, g) Walktrap This algorithm starts with computing a transition matrix \\[\\mathbf{T_{ij}}\\] in which each matrix element \\[p_{ij}\\] is the probability of one node \\[i\\] traversing to another node \\[j\\]. \\[\\mathbf{T_{ij}} = \\left[\\begin{array} {rrr} p_{11} &amp; p_{12} &amp; p_{13} \\\\ p_{21} &amp; p_{22} &amp; p_{23} \\\\ p_{31} &amp; p_{32} &amp; p_{33} \\end{array}\\right]\\] In the matrix above, \\[p_{32}\\] is th probability that node 3 traverses to node 2 as determined by the node strengths of the two nodes. Ward’s agglomorative clustering approach is employed wherein nodes start off as a cluster of their own and then merge with adjacent clusters. The merging takes place in a way where the sum of squared distances between clusters are reduced. #Random Walk wk &lt;- walktrap.community(df); wk ## IGRAPH clustering walktrap, groups: 200, mod: 0 ## + groups: ## $`1` ## [1] &quot;p1&quot; ## ## $`2` ## [1] &quot;p2&quot; ## ## $`3` ## [1] &quot;p3&quot; ## ## $`4` ## + ... omitted several groups/vertices # membership(wk) # communities(wk) Infomap This is similar to the greedy walk algorithm except it converts the random walk information into a binary coding system. The partition of data into networks is carried out in a way that maximizes the information of random walks. # Infomap imc &lt;- cluster_infomap(df);imc ## IGRAPH clustering infomap, groups: 1, mod: 0 ## + groups: ## $`1` ## [1] &quot;p1&quot; &quot;p2&quot; &quot;p3&quot; &quot;p4&quot; &quot;p5&quot; &quot;p6&quot; &quot;p7&quot; &quot;p8&quot; &quot;p9&quot; &quot;p10&quot; ## [11] &quot;p11&quot; &quot;p12&quot; &quot;p13&quot; &quot;p14&quot; &quot;p15&quot; &quot;p16&quot; &quot;p17&quot; &quot;p18&quot; &quot;p19&quot; &quot;p20&quot; ## [21] &quot;p21&quot; &quot;p22&quot; &quot;p23&quot; &quot;p24&quot; &quot;p25&quot; &quot;p26&quot; &quot;p27&quot; &quot;p28&quot; &quot;p29&quot; &quot;p30&quot; ## [31] &quot;p31&quot; &quot;p32&quot; &quot;p33&quot; &quot;p34&quot; &quot;p35&quot; &quot;p36&quot; &quot;p37&quot; &quot;p38&quot; &quot;p39&quot; &quot;p40&quot; ## [41] &quot;p41&quot; &quot;p42&quot; &quot;p43&quot; &quot;p44&quot; &quot;p45&quot; &quot;p46&quot; &quot;p47&quot; &quot;p48&quot; &quot;p49&quot; &quot;p50&quot; ## [51] &quot;p51&quot; &quot;p52&quot; &quot;p53&quot; &quot;p54&quot; &quot;p55&quot; &quot;p56&quot; &quot;p57&quot; &quot;p58&quot; &quot;p59&quot; &quot;p60&quot; ## [61] &quot;p61&quot; &quot;p62&quot; &quot;p63&quot; &quot;p64&quot; &quot;p65&quot; &quot;p66&quot; &quot;p67&quot; &quot;p68&quot; &quot;p69&quot; &quot;p70&quot; ## [71] &quot;p71&quot; &quot;p72&quot; &quot;p73&quot; &quot;p74&quot; &quot;p75&quot; &quot;p76&quot; &quot;p77&quot; &quot;p78&quot; &quot;p79&quot; &quot;p80&quot; ## [81] &quot;p81&quot; &quot;p82&quot; &quot;p83&quot; &quot;p84&quot; &quot;p85&quot; &quot;p86&quot; &quot;p87&quot; &quot;p88&quot; &quot;p89&quot; &quot;p90&quot; ## + ... omitted several groups/vertices # membership(imc) #communities(imc) # plot(fg, g) Eigen vector This involves computing an eigenvector for the modularity matrix and splitting the network into communities in order to improve modularity. A stopping condition is specified to avoid tight communities to be formed. Due to eigenvector computations, this algorithm does not work well with degerate graphs. # Eigen vector community eg &lt;- leading.eigenvector.community(df);eg ## IGRAPH clustering leading eigenvector, groups: 1, mod: 0 ## + groups: ## $`1` ## [1] &quot;p1&quot; &quot;p2&quot; &quot;p3&quot; &quot;p4&quot; &quot;p5&quot; &quot;p6&quot; &quot;p7&quot; &quot;p8&quot; &quot;p9&quot; &quot;p10&quot; ## [11] &quot;p11&quot; &quot;p12&quot; &quot;p13&quot; &quot;p14&quot; &quot;p15&quot; &quot;p16&quot; &quot;p17&quot; &quot;p18&quot; &quot;p19&quot; &quot;p20&quot; ## [21] &quot;p21&quot; &quot;p22&quot; &quot;p23&quot; &quot;p24&quot; &quot;p25&quot; &quot;p26&quot; &quot;p27&quot; &quot;p28&quot; &quot;p29&quot; &quot;p30&quot; ## [31] &quot;p31&quot; &quot;p32&quot; &quot;p33&quot; &quot;p34&quot; &quot;p35&quot; &quot;p36&quot; &quot;p37&quot; &quot;p38&quot; &quot;p39&quot; &quot;p40&quot; ## [41] &quot;p41&quot; &quot;p42&quot; &quot;p43&quot; &quot;p44&quot; &quot;p45&quot; &quot;p46&quot; &quot;p47&quot; &quot;p48&quot; &quot;p49&quot; &quot;p50&quot; ## [51] &quot;p51&quot; &quot;p52&quot; &quot;p53&quot; &quot;p54&quot; &quot;p55&quot; &quot;p56&quot; &quot;p57&quot; &quot;p58&quot; &quot;p59&quot; &quot;p60&quot; ## [61] &quot;p61&quot; &quot;p62&quot; &quot;p63&quot; &quot;p64&quot; &quot;p65&quot; &quot;p66&quot; &quot;p67&quot; &quot;p68&quot; &quot;p69&quot; &quot;p70&quot; ## [71] &quot;p71&quot; &quot;p72&quot; &quot;p73&quot; &quot;p74&quot; &quot;p75&quot; &quot;p76&quot; &quot;p77&quot; &quot;p78&quot; &quot;p79&quot; &quot;p80&quot; ## [81] &quot;p81&quot; &quot;p82&quot; &quot;p83&quot; &quot;p84&quot; &quot;p85&quot; &quot;p86&quot; &quot;p87&quot; &quot;p88&quot; &quot;p89&quot; &quot;p90&quot; ## + ... omitted several groups/vertices 5.1 Values data set.seed(133) val_data &lt;- data_val %&gt;% group_by(country) %&gt;% sample_n(50) %&gt;% ungroup %&gt;% dplyr::select(-country) %&gt;% t %&gt;% cor #Plot the correlations reshape2::melt(val_data) %&gt;% ggplot(aes(x=value)) + geom_density(fill=&quot;#69b3a2&quot;, color=&quot;#e9ecef&quot;, alpha=0.8)+ labs(title = &quot;Distribution of correlations - Values Raw data&quot;, x = &quot;Range of correlation values&quot;)+ theme_ipsum() + theme(plot.title = element_text(size=9)) g &lt;- graph.adjacency(val_data, mode=&quot;upper&quot;, weighted=TRUE, diag=FALSE) e &lt;- get.edgelist(g) df &lt;- as.data.frame(cbind(e,E(g)$weight)) df &lt;- graph_from_data_frame(df, directed = F) # edge betweenness #eb &lt;- edge.betweenness.community(df);eb #plot(eb, df) # Louvain lc &lt;- cluster_louvain(df);lc ## IGRAPH clustering multi level, groups: 1, mod: 0 ## + groups: ## $`1` ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; &quot;6&quot; &quot;7&quot; &quot;8&quot; &quot;9&quot; &quot;10&quot; &quot;11&quot; &quot;12&quot; ## [13] &quot;13&quot; &quot;14&quot; &quot;15&quot; &quot;16&quot; &quot;17&quot; &quot;18&quot; &quot;19&quot; &quot;20&quot; &quot;21&quot; &quot;22&quot; &quot;23&quot; &quot;24&quot; ## [25] &quot;25&quot; &quot;26&quot; &quot;27&quot; &quot;28&quot; &quot;29&quot; &quot;30&quot; &quot;31&quot; &quot;32&quot; &quot;33&quot; &quot;34&quot; &quot;35&quot; &quot;36&quot; ## [37] &quot;37&quot; &quot;38&quot; &quot;39&quot; &quot;40&quot; &quot;41&quot; &quot;42&quot; &quot;43&quot; &quot;44&quot; &quot;45&quot; &quot;46&quot; &quot;47&quot; &quot;48&quot; ## [49] &quot;49&quot; &quot;50&quot; &quot;51&quot; &quot;52&quot; &quot;53&quot; &quot;54&quot; &quot;55&quot; &quot;56&quot; &quot;57&quot; &quot;58&quot; &quot;59&quot; &quot;60&quot; ## [61] &quot;61&quot; &quot;62&quot; &quot;63&quot; &quot;64&quot; &quot;65&quot; &quot;66&quot; &quot;67&quot; &quot;68&quot; &quot;69&quot; &quot;70&quot; &quot;71&quot; &quot;72&quot; ## [73] &quot;73&quot; &quot;74&quot; &quot;75&quot; &quot;76&quot; &quot;77&quot; &quot;78&quot; &quot;79&quot; &quot;80&quot; &quot;81&quot; &quot;82&quot; &quot;83&quot; &quot;84&quot; ## [85] &quot;85&quot; &quot;86&quot; &quot;87&quot; &quot;88&quot; &quot;89&quot; &quot;90&quot; &quot;91&quot; &quot;92&quot; &quot;93&quot; &quot;94&quot; &quot;95&quot; &quot;96&quot; ## [97] &quot;97&quot; &quot;98&quot; &quot;99&quot; &quot;100&quot; &quot;101&quot; &quot;102&quot; &quot;103&quot; &quot;104&quot; &quot;105&quot; &quot;106&quot; &quot;107&quot; &quot;108&quot; ## + ... omitted several groups/vertices # membership(lc) # communities(lc) # plot(lc, g) # Infomap imc &lt;- cluster_infomap(df);imc ## IGRAPH clustering infomap, groups: 1, mod: 0 ## + groups: ## $`1` ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; &quot;6&quot; &quot;7&quot; &quot;8&quot; &quot;9&quot; &quot;10&quot; &quot;11&quot; &quot;12&quot; ## [13] &quot;13&quot; &quot;14&quot; &quot;15&quot; &quot;16&quot; &quot;17&quot; &quot;18&quot; &quot;19&quot; &quot;20&quot; &quot;21&quot; &quot;22&quot; &quot;23&quot; &quot;24&quot; ## [25] &quot;25&quot; &quot;26&quot; &quot;27&quot; &quot;28&quot; &quot;29&quot; &quot;30&quot; &quot;31&quot; &quot;32&quot; &quot;33&quot; &quot;34&quot; &quot;35&quot; &quot;36&quot; ## [37] &quot;37&quot; &quot;38&quot; &quot;39&quot; &quot;40&quot; &quot;41&quot; &quot;42&quot; &quot;43&quot; &quot;44&quot; &quot;45&quot; &quot;46&quot; &quot;47&quot; &quot;48&quot; ## [49] &quot;49&quot; &quot;50&quot; &quot;51&quot; &quot;52&quot; &quot;53&quot; &quot;54&quot; &quot;55&quot; &quot;56&quot; &quot;57&quot; &quot;58&quot; &quot;59&quot; &quot;60&quot; ## [61] &quot;61&quot; &quot;62&quot; &quot;63&quot; &quot;64&quot; &quot;65&quot; &quot;66&quot; &quot;67&quot; &quot;68&quot; &quot;69&quot; &quot;70&quot; &quot;71&quot; &quot;72&quot; ## [73] &quot;73&quot; &quot;74&quot; &quot;75&quot; &quot;76&quot; &quot;77&quot; &quot;78&quot; &quot;79&quot; &quot;80&quot; &quot;81&quot; &quot;82&quot; &quot;83&quot; &quot;84&quot; ## [85] &quot;85&quot; &quot;86&quot; &quot;87&quot; &quot;88&quot; &quot;89&quot; &quot;90&quot; &quot;91&quot; &quot;92&quot; &quot;93&quot; &quot;94&quot; &quot;95&quot; &quot;96&quot; ## [97] &quot;97&quot; &quot;98&quot; &quot;99&quot; &quot;100&quot; &quot;101&quot; &quot;102&quot; &quot;103&quot; &quot;104&quot; &quot;105&quot; &quot;106&quot; &quot;107&quot; &quot;108&quot; ## + ... omitted several groups/vertices # membership(imc) # communities(imc) # plot(imc, g) #Fast and greedy algorithm fg &lt;- fastgreedy.community(df); fg ## IGRAPH clustering fast greedy, groups: 2, mod: 1.9e-17 ## + groups: ## $`1` ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; &quot;6&quot; &quot;7&quot; &quot;8&quot; &quot;9&quot; &quot;10&quot; &quot;11&quot; &quot;12&quot; ## [13] &quot;13&quot; &quot;14&quot; &quot;15&quot; &quot;16&quot; &quot;17&quot; &quot;18&quot; &quot;19&quot; &quot;20&quot; &quot;21&quot; &quot;22&quot; &quot;23&quot; &quot;24&quot; ## [25] &quot;25&quot; &quot;26&quot; &quot;27&quot; &quot;28&quot; &quot;29&quot; &quot;30&quot; &quot;31&quot; &quot;32&quot; &quot;33&quot; &quot;34&quot; &quot;35&quot; &quot;36&quot; ## [37] &quot;37&quot; &quot;38&quot; &quot;39&quot; &quot;40&quot; &quot;41&quot; &quot;42&quot; &quot;43&quot; &quot;44&quot; &quot;45&quot; &quot;46&quot; &quot;47&quot; &quot;48&quot; ## [49] &quot;49&quot; &quot;50&quot; &quot;51&quot; &quot;52&quot; &quot;53&quot; &quot;54&quot; &quot;55&quot; &quot;56&quot; &quot;57&quot; &quot;58&quot; &quot;59&quot; &quot;60&quot; ## [61] &quot;61&quot; &quot;62&quot; &quot;63&quot; &quot;64&quot; &quot;65&quot; &quot;66&quot; &quot;67&quot; &quot;68&quot; &quot;69&quot; &quot;70&quot; &quot;71&quot; &quot;72&quot; ## [73] &quot;73&quot; &quot;74&quot; &quot;75&quot; &quot;76&quot; &quot;77&quot; &quot;78&quot; &quot;79&quot; &quot;80&quot; &quot;81&quot; &quot;82&quot; &quot;83&quot; &quot;84&quot; ## [85] &quot;85&quot; &quot;86&quot; &quot;87&quot; &quot;88&quot; &quot;89&quot; &quot;90&quot; &quot;91&quot; &quot;92&quot; &quot;93&quot; &quot;94&quot; &quot;95&quot; &quot;96&quot; ## [97] &quot;97&quot; &quot;98&quot; &quot;99&quot; &quot;100&quot; &quot;101&quot; &quot;102&quot; &quot;103&quot; &quot;104&quot; &quot;105&quot; &quot;106&quot; &quot;107&quot; &quot;108&quot; ## + ... omitted several groups/vertices # membership(fg) # communities(fg) # Eigen vector community eg &lt;- leading.eigenvector.community(df);eg ## IGRAPH clustering leading eigenvector, groups: 1, mod: 0 ## + groups: ## $`1` ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; &quot;6&quot; &quot;7&quot; &quot;8&quot; &quot;9&quot; &quot;10&quot; &quot;11&quot; &quot;12&quot; ## [13] &quot;13&quot; &quot;14&quot; &quot;15&quot; &quot;16&quot; &quot;17&quot; &quot;18&quot; &quot;19&quot; &quot;20&quot; &quot;21&quot; &quot;22&quot; &quot;23&quot; &quot;24&quot; ## [25] &quot;25&quot; &quot;26&quot; &quot;27&quot; &quot;28&quot; &quot;29&quot; &quot;30&quot; &quot;31&quot; &quot;32&quot; &quot;33&quot; &quot;34&quot; &quot;35&quot; &quot;36&quot; ## [37] &quot;37&quot; &quot;38&quot; &quot;39&quot; &quot;40&quot; &quot;41&quot; &quot;42&quot; &quot;43&quot; &quot;44&quot; &quot;45&quot; &quot;46&quot; &quot;47&quot; &quot;48&quot; ## [49] &quot;49&quot; &quot;50&quot; &quot;51&quot; &quot;52&quot; &quot;53&quot; &quot;54&quot; &quot;55&quot; &quot;56&quot; &quot;57&quot; &quot;58&quot; &quot;59&quot; &quot;60&quot; ## [61] &quot;61&quot; &quot;62&quot; &quot;63&quot; &quot;64&quot; &quot;65&quot; &quot;66&quot; &quot;67&quot; &quot;68&quot; &quot;69&quot; &quot;70&quot; &quot;71&quot; &quot;72&quot; ## [73] &quot;73&quot; &quot;74&quot; &quot;75&quot; &quot;76&quot; &quot;77&quot; &quot;78&quot; &quot;79&quot; &quot;80&quot; &quot;81&quot; &quot;82&quot; &quot;83&quot; &quot;84&quot; ## [85] &quot;85&quot; &quot;86&quot; &quot;87&quot; &quot;88&quot; &quot;89&quot; &quot;90&quot; &quot;91&quot; &quot;92&quot; &quot;93&quot; &quot;94&quot; &quot;95&quot; &quot;96&quot; ## [97] &quot;97&quot; &quot;98&quot; &quot;99&quot; &quot;100&quot; &quot;101&quot; &quot;102&quot; &quot;103&quot; &quot;104&quot; &quot;105&quot; &quot;106&quot; &quot;107&quot; &quot;108&quot; ## + ... omitted several groups/vertices # communities(eg) #Random Walk wk &lt;- walktrap.community(df); wk ## IGRAPH clustering walktrap, groups: 150, mod: 0 ## + groups: ## $`1` ## [1] &quot;1&quot; ## ## $`2` ## [1] &quot;2&quot; ## ## $`3` ## [1] &quot;3&quot; ## ## $`4` ## + ... omitted several groups/vertices # membership(wk) # communities(wk) "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
